#!/bin/sh

# Then another procedure parses the output in reverse. When it  stumbles upon a
# pipe character it defines at what exact position it is and adds a value to a
# special list. This list marks at what positions the pipes should be, but the
# addition of pipes and the list creation should happen at the same time.
# Otherwise pipes from the higher part of the output end up being everywhere.
# And also i need to check if a counterpart to a pipe character on a line above
# is a whitespace or not.


# find . | sort | tac | while IFS= read line; do
# line="|____./init.lua"

# character="$(echo "$line" | awk '{print substr($0, 6, 1)}')"
# echo "This is the current line: \n$line"
# echo "This is the seventh character on the current line: $character"
# done



process() {
cd ~/test
input="$(find . | sort )"
# echo "This is input: \n$input\n"

count=1

find . | sort | while IFS= read line; do
if [ "$line" = "." ]; then
	continue
else
	line_length="$(echo "$line" | wc -m)"
	truncated_line="$(echo $line | sed 's/\.\/.*\///')"
	truncated_line_length="$(echo "$truncated_line" | wc -m)"
	difference="$(expr "$line_length" - "$truncated_line_length")"
	spaces=""

	
	for i in $(seq $difference); do 
		spaces="$spaces "
	done
	processed_line="$spaces|____$truncated_line"
	if [ "$(echo "$processed_line" | cut -c1)" = " " ]; then
		# echo "The line starts with a whitespace, a pipe should be added."
		processed_line="|$processed_line"
		echo "$processed_line"
	else
		# echo "The line doesn't start with a whitespace."
		echo "$processed_line"
	fi
	# echo "This is value of the count befor the if condition: $count"
	# if [ "$count" = "1" ]; then
	# 	echo "This is the first line: $processed_line"
	# else
	# 	echo "This is not the first line"
	# fi

fi
# count="$(expr $count + 1)"
# echo "Current count: $count"
done
}

replace_char_at() {
    line="$1"  # Original line
    pos="$2"   # Position (1-based index)
    char="$3"  # New character

    echo "$line" | awk -v pos="$pos" -v char="$char" '{
        print substr($0, 1, pos-1) char substr($0, pos+1)
    }'
}

process_in_reverse() {
	previous_line=""
	pipe_positions=""
	offset=1
	# awk '{print $0}' | while IFS= read line; do
	while IFS= read line; do
		line_length="$(echo "$line" | wc -m)"
		# echo "This is a line length: $line_length"
		# echo "This is a line: $line"
		# echo "$line"
		modified_line="$line"
		for i in $(seq $line_length); do
			current_character="$(echo "$line" | awk -v offset=$offset '{print substr($0, offset, 1)}')"
			for pipe_position in $pipe_positions; do
				previous_line_character="$(echo $previous_line | awk -v offset=$current_character '{print substr($0, offset, 1)}')"
				# echo "This is the previous line: $previous_line"
				# echo "This is the previous line character: $previous_line_character"
				# echo "This is the current character: $current_character"
				if [ "$previous_line_character" = "|" ] && [ "$current_character" = " " ]; then
					modified_line=$(replace_char_at "$line" "$pipe_position" "|")
					# echo "This is a modified line: $modified_line"
					$pr_line
				else
					# echo "The condition wasn't triggered"
					continue
				fi
			done	
			if [ "$current_character" = '|' ]; then
				pipe_positions="$pipe_positions $offset"
			fi

			# echo "This is the current character: $character and this its position is $offset"
			offset="$(expr $offset + 1)"
			# echo "This is the current offset: $offset"
		done
		echo "$modified_line"
		previous_line="$line"
	done
}


# echo "This is the original output:"
# process
# echo "\n"

# # echo "\nThis is the reverse output:"
# echo "\nThis is the final output:"
# # process | process_in_reverse | tac
# process | tac | process_in_reverse

process | tac > /tmp/reversed_file
process_in_reverse < /tmp/reversed_file | tac
rm /tmp/reversed_file

