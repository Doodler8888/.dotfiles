#!/bin/sh

# main() {
# 	if [ -z $1 ]; then
# 		# find . | sort | sed 's/\.\//|___/;s/.*\//|   |___/g' ]
# 		find . | sort | sed 's/.*\//|___/;s/.*\//|   |___/g' ]
# 	else 
# 		find $1 | 
# 	fi

# We need to create a pattern "anything before a slash, but not a slash itself.".
# Then we count how many characters ended up in the caputured pattern

# First, i need to create a loop that counts a number of characters on each line.

# cd ~/test

# input="$(find . | sort )"

# echo "This is input: \n$input"

cd ~/test
input="$(find . | sort )"
echo "This is input: \n$input\n"

find . | sort | while IFS= read line; do
# find . | sort | while IFS= read -r line; do
if [ "$line" = "." ]; then
	continue
else
	line_count="$(echo "$line" | wc -m)"
	# echo "This is the line count: $line_count"
	truncated_line="$(echo $line | sed 's/\.\/.*\///')"
	truncated_line_count="$(echo "$truncated_line" | wc -m)"
	# echo "This is the truncated line count: $truncated_line_count"
	# echo "This is a truncated line:\n$truncated_line"
	difference="$(expr "$line_count" - "$truncated_line_count")"
	# echo "This is the difference: $difference"
	spaces=""
	# The point of the loop is that i condition is that it iterates over each
	# item generated by seq. It's number about the numbers per se, but about the
	# amount of numbers. That's why i don't use double quotes, because in this
	# case i only end up having only one item.
	for i in $(seq $difference); do 
		# echo "Should add one space to the spaces string."
		spaces="$spaces "
	done
	# echo "This are spaces: {$spaces}"
	# processed_line="$(echo "$truncated_line" | sed "s/^/$spaces/")"
	# processed_line="$spaces$truncated_line"
	# echo "One loop rotation ended.\n"
	# echo $processed_line
	# processed_line=$(echo "$spaces|____$truncated_line")
	# echo "$spaces|____$truncated_line"
	processed_line="$spaces|____$truncated_line"
	# echo "$processed_line"
	# echo "First character: $(echo "$processed_line" | cut -c -1)\n"
	if [ "$(echo "$processed_line" | cut -c1)" = " " ]; then
		# echo "The line starts with a whitespace, a pipe should be added."
		processed_line="|$processed_line"
		echo "$processed_line"
	else
		# echo "The line doesn't start with a whitespace."
		echo "$processed_line"
	fi
fi
done


# '<,'>s/\.\/.*\/


#
#
#
#
#
#
#
#
# # main() {
# # 	if [ -z $1 ]; then
# # 		find . | sort | sed -e 's;[^/]*/;|____;g;s;____|;   |;g'
# # 	else 
# # 		find $1 | sort | sed -e 's;[^/]*/;|____;g;s;____|;   |;g'
# # 	fi
# # }
#
# case "$(basename $0)" in 
# 	tree) main $1 ;;
# esac
#
